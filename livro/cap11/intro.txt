sockets e redes
O servidor de internte knock-knock
C é utilizado para escrever a maior parte de código de rede de baixo nível na
internet. A maioria das aplicações precisa de dois programas separados: um
servidor e um cliente. Você vai criar um server em C que conta piadas pela
internt. Você também será capaz de inicializar o servidor em uma máquina assim:

    ./ikkp_server
    Waiting for connection

Além de avisar que está em execução, o servidor não exibirá mais nada na tela.
Entretanto, se abrir um segundo console, poderá se conectar ao servidor usando
um programa cliente chamado telnet. Telnet usa dois parâmetros: o endereço do
servidor e a porta onde o servidor está sendo executado. Se estiver executando
telnet na mesma máquina que o servidor, você pode usar 127.0.0.1 para o
endereço:

    telnet 127.0.0.1 30000

VISÃO GERAL DO SERVIDOR KNOCK-KNOCK
O servidor será capaz de conversar com vários clientes ao mesmo tempo. O
cliente e o servidor terão uma conversa estruturada, chamada protocolo. Há
diferentes protocolos em uso na internet. Alguns deles são protocolos de baixo
nível, como internet protocol (IP - protocolo da internt), que são usados para
controlar como 1s e 0s binários são enviados pela internet. Outros protocolos
são de alto nível, como o hypertext transfer protocol (HTTP - protocolo de
transferência de hipertexto), que controla como navegadores web conversam com
os servidores web. O servidor de piadas vai usar um protocolo de alto nível
customizado, chamado internet knock-knock protocol(IKKP - protocolo de internet
"knock-knock").

O cliente e o servidore irão trocar mensagens assim:
    Servidor        Cliente
    Knock knock
                    Who's there?
    Oscar
                    Oscar who?
    Oscar silly question, you
    get a silly answer
Um protocolo sempre tem uma lista de regras rógidas. Enquando o cliente e o
servidor seguirem as regrasm tudo estrará bem. Mas se um deles quebrar as
regras, a conversa geralmente termina abruptamente.

BLAB: COMO SERVIDORES CONVERSAM COM A INTERNET
Quando programas em C precisam conversar com o mundo exteriror, eles usam
fluxos de dados para ler e escrever bytes. Você usou fluxos de dados que são
conectados aos arquivos ou Standard Input/Output (Entrada e saída padrão). Mas
se for escrever um programa para conversar com a rede, você precisa de um novo
tipo de fluxo d dados chamado socket.

    #include <sys/socket.h>//você vai precisar deste header
    ...
    //listener_d é um descritor para o socket. É um socket de internet
    int listener_d = socket(PF_INET, SOCK_STREAM, 0);//este é um número de protocolo. Você pode deixá-lo como 0
    if (listener_d == -1) 
        error("Can't open socket");//Esta é a função error() que você criou no último capítulo.

Antes de um servidor poder usar um socket para conversar com um programa
cliente,  ele precisa passar por quatro etapas, que podem ser lembradas com a
sigla BLAB: Bind, Listen, Accept, Begin; (Vincular, Escutar, Aceitar, Começar).

1. BIND - VINCULAR A UMA PORTA.
Um computador precisa executar vários programas servidores ao mesmo tempo.
Talvez esteja enviando páginas web, enviando e-mails e executando um
servidor de chat simultaneamente. Para evitar que as conversas se misturem,
cada servidor usa uma porta diferente. Uma porta é como um canal de TV.
Portas diferentes são usadas para diferentes serviços de rede, da mesma
forma que canais diferentes são usados para conteúdos diferentes.
Quando um servidor é inicializado, ele precisa dizer ao sistema operacional
qual porta vai usar. Isso se chama se vincular a uma porta. O servidor
knock-knock vai usar a porta 30000 e, para descritor de socket e o nome de
socket. Um nome de socket é apenas um struct que significa "porta de
internet 30000".

    #include <arpa/inet.h>//você vai precisar desse header para criar endereços de internet
    ...
    struct sockadd_in name;//essas 3 linhas criam um nome para a pporta e que significa "porta de internet 30000"
    name.sin_family = PF_INET;
    name.sin_port = (in_port_t)htons(30000);
    name.sin_addr.s_addr = htonl(INADDR_ANY);
    int c = bind (listener_d, (struct sockadd *) &name, sizeof(name));
    if (c == -1)
        error("Can't bind to socket'");

2. LISTEN - ESCUTAR
Se seu servidor se tornar popular, é bem provável que receva muitos
clientes se conectando a ele ao mesmo tempo. Gostaria que os clientes
esperassem em uma fila para fazer a conexão? A chamada ao sistema (system
call) liste() diz ao sistema operacional qual tamanho você quer que a fila
tenha:

    if (listen(listener_d, 10) == -1)
        error("Can't listen");

Chamar liste() com uma fila de tamanho 10 significa que até dez clientes podem
tentar se conectar ao servidor ao mesmo tempo. Nem todos receberão uma resposta
imediata, mas podem esperar por ela. O 11º cliente será avisado que o servidor
está muito ocupado.

3. ACEITAR UMA CONEXÃO
Uma vez que esteja vinculando a uma porta e tenha criado a fila de escuta, você
precisa apenas... esperar. Servidores passam a maior parte da visa esperando
clientees se conectarem a eles. A chamada ao sistema conectarem a eles. A
chamada ao sistema accept() espera até um cliente entrar em contato com o
servidor, depois retorna um segundo descritor de socket que pode ser utilizado
para transmitir uma conversa.

    struct sockadd_storage client_add;
    unsigned int address_size = sizeof(client_add);
    int connect_d = accept(listener_d, (struct sockaddr *)&client_addr, &address_size);
    if (connect_d == -1)
        error("Can't open secondary socket");

Este novo descritor de conexão (connect_d) é o que o servidor vai usar para..
COMEÇAR A CONVERSA.

UM SOCKET NÃO É UM TÍPICO FLUXO DE DADOS
Até agora, os fluxos de dados têm sido todos iguais. Independentemente de estar
conectados a arquivos ou Standard Input/Output (Entradas e Saídas Padrão), você
tem usado funções como fprintf() e fscanf() para conversar com eles. Mas
sockets são um poucos diferentes. Um socket tem mão dupla: pode ser usado para
entrada e saída. Isso significa que ele precisa de funções diferentes para
conversar.
Se quiser exportar dados em um socket, você não pde usar fprintf(). Ao invés
disso, use a função de chamada send():

    char *msg = "Internet Knock-Knock Protocol Server\r\nVersion 1.0\r\nKnock! Knock!\r\n>";//esta é a mensagem que vai enviar pela rede
    if (send(connect_d, msgm strle(msg), 0) == -1)
        error("send");

Lembre-se: é importante sempre verificar o valor de retorno de chamadas de
sistema como send(). Erros de rede são muito comuns, e seus servidores precisam
lidar com eles.

portas vinculadas são pegajosas
Quando vincular um socket a uma porta, o sistema operacional vai impedir que
qualquer outra coisa se vincule a ela pelos próximos 30 segundos,
aproximadamente, e  isso inclui o programa que vinculou a porta originalmente.
Para lidar com este problema, você só precisa inserir uma opção no socket antes
de vinculá-lo:

    int reuse = 1;
    if (setsockopt(listener_d, SOL_SOCKET, SO_REUSEADDR, (char*)&reuse, sizeof(int)) == -1)
        error("Can't set the reuse option on the socket");

Este código faz com que o socket reutilize a porta quando estiver vinculado.
Isso significa que você pode parar e reiniciar o servidor e não haverá erros
quando vincular a porta uma segunda vez.

LENDO DADOS DO CLIENTE
você aprendeu como enviar dados para o cliente, mas e ler dados do cliente? Da
mesma maneira que sockets têm uma função especial send() para escrever dados,
ele também têm uma função recv() para a leitura de dados.

    <bytes read> = recv(<descriptor>, <buffer>, <bytes to read>, 0);

Se alguém escrever uma linha de texto no cliente e enviá-la, a função recv()
armazena o texto em um array de caracteres assim:

    [W][h][o]['][s][ ][t][h][e][r][e][?][\r][\n]

Há algumas coisas para lembrar:
(*) Os caracteres não terminam com um caracter \0.
(*) Quando alguém escrever texto em telnet, a string sempre terminar com \r\n
(*) A função recv() vai retornar o número de caracteres, ou -1 se tiver um
erro, ou () se o cliente fechar a conexão.
(*) Não é garantido que você receberá todos os caracteres em uma única chamada
a recv().

Este último ponto é importante. Significa que talvez tenha de chamar recv()
mais de uma vez. Significa também que recv() pode ser um pouco difícil de usar.
É melhor embrular recv() em uma função que armazena um simples string que
termina com \0 no array que lhe é dado. Algo parecido com isso:

int read_in(int socket, char *buf, int len)
{
    char *s = buf;
    int slen = len;
    int c = recv(socket, s, slen, 0);
    while((c > 0) && (s[c-1] != '\n')) {
        s += c;
        slen -= c;
        c = recv(socket, s, slen, 0);
    }
    if (c < 0)
        return c;
    else if (c == 0)
        buf[0] = '\0';
    else
        s[c-1] = '\0';
    return len - slen;
}


void error(char *msg)
{
    fprintf(stderr, "%s - %s\n", msg, strerror(errno));
    exit(1);
}

int open_listener_socket()
{
    int s = socket(PF_INET, SOCK_STREAM, 0);
    if (s == -1) error("Can't open socket");
    return s;
}

void bind_to_port(int socket, int port)
{
    struct sockaddr_in name;
    name.sin_family = PF_INER;
    name.sin_port = (in_port_t)htons(30000);//port fica aqui
    name.sin_addr = htons(INADDR_ANY);
    int reuse = 1;
    if (setsockopt(socket, SOL_SOCKET, SO_REUSEADOR, (char*)&reuse, sizeof(int))== -1)
        error("Can't set the reuse option on the socket");
    int c = bind(socket, (struct sockadd*)&name, sizeof(name));
    if (c == -1)
        error("Can't bin to socket'");
}

int say(int socket, char *s)
{
    int result = send(socket, s, strlen(s), 0);
    if (result == -1)
        fprintf(stderr, "%s: %s\n", "Erro talkinh to the client", strerr(errno));
    return result;
}

VOCÊ PODE FORK() UM PROCESSO PARA CADA CLIENTE
Quando os clientes se conectam ao servidor, eles começam uma conversa em um
socket separado e recém-criado. Isso significa que o socket de servidor
principal está livre para procurar outro cliente. Então vamos fazer isso.
Quando um cliente se conecta, você pode fork() um processo filho separado para
lidar com a conversa entre servidor e cliente.
Enquanto o cliente estiver conversando com o processo filho, o processo pai do
servidor pode se conectar ao próximo cliente.

O PAI E O FILHO USAM SOCKETS DIFERENTES
Uma coisa a se ter em mente é que o processo pai do servidor só precisa usar o
socket de escuta principal. Isso acontece porque ele é o que chama accept()
para aceitar novas conexões. Por outro lado, o processo filho sempre terá de
lidar apenas com o socket secundário que é criado pela chamada accept(). Isso
significa que uma vez que o pai chamou fork() para o filho, o pai pode fechar o
socket secundário e o filho pode fechar o socket de escuta principal.
    
    close(connect_d);//depos de fork-ar o filho, o pai pode fechar este socket
    close(listener_d);//uma vez que o filho for criado, ele pode fechar este socket

ESCREVENDO UM CLIENTE WEB
E se quiser escrever seu próprio programa cliente? É realmente tão diferente
assim de um servidor? Para ver a semelhanças e diferenças, você vai ter de
criar um cliente web para o protocolo de transferencia de hipertexto (HTTP);
HTTP é muito parecido com o protocolo de internet knock-knock que você
programou faz pouco tempo. Todo os protocolos são conversas estruturadas. Cada
vez que um cliente e servidor web conversam, eles dizem o mesmo tipo de coisa.
Abra telnet e veja como baixar http://en.wikipedia.org/wiki/O'Relly_Media

Quando seu programa se conectar ao servidor web, vau precisar enviar pelo menos
trê coisas:
(*) Um comando GET
    GET /wiki/O'Reilly_Media http/1.1
(*) O nome de domínio
    Host: en.wikipedia.org
(*) Uma linha em branco
Mas, antes de poder enviar quaisquer dados para o servidor, você precisa fazer
uma conexão do cliente. E como se faz isso?

CLIENTES QUE MANDAM
Clientes e servidores se comunicam usando sockets, mas a maneira que cada um
consegue um socket é um pouco diferente. Você já viu que servidores usam a
sequência BLAB:
    (*) Bind    Vincular a uma porta
    (*) Listen  Escutar
    (*) Accept  Aceitar
    (*) Begin   Começar a conversa
Um servidor passa a maioria da sua vida esperando uma nova conexão de um
cliente. Até um cliente se conectar, um servidor não pode fazer nada. Clientes
não têm este problema. Um cliente pode se conectar e começar a conversa com um
servidor quando quiser. Esta é a sequência para um cliente:
    (*) Conectar-se a uma porta remota
    (*) Começar a conversar.

PORTAS REMOTAS E ENDEREÇOS IP
Quando um servidor se conecta à rede, ele precisa decidir que porta vai usar.
Mas clientes precisam saber um pouco mais: precisam saber a porta do servidor
remoto, mas também precisam saber seu endereço de protocolo de internet (IP):

    208.201.239.100

Endereços de internet são um pouco difíceis de lembrar, por isso geralmente
seres humanos usam nomes de domínios. Um nome de domínio é só um trecho de
texto mais fácil de se lembrar como:

    www.oreilly.com

Apesar de seres humanos preferirem nomes de domínio, os pacotes de informação
reais que trafegam na rede usam apenas o endereço de IP númericos.

CRIE UM SOCKET PARA UM ENDEREÇO IP
Uma vez que seu cliente saiba o endereço e número de porta do servidor, ele
pode criar um socket de clients de servidor são criados da mesma maneira:

    int s = socket(PF_INET, SOCK_STREAM, 0);

A diferença entre o código do cliente e o servidor é o que eles fazem com o
sockets quando o criam. Um servidor vai vincular o socket a uma porta local,
mas um cliente vai conextar o socket a uma porta remota;
    
    //essas linhas criam um endereço socket  
    struct sockaddr_in si;
    memset(&si, 0, sizeof(si));
    si.sin_family = PF_INET;
    si.sin_addr.s_addr = inet_addr("208.201.239.100");//servidor
    si.sin_port = htons(80);
    connect(s, (struct sockaddr*)&si, sizeof(si));//Esta linha conecta o socket à porta remota

O código acima funciona apenas para endereços IP numéricos. Para conectar um
socket a um nome de domínio, você vai precisar usar de uma função chamada
getaddrinfo().

GETADDRINFO() PEGA ENDEREÇOS PARA DOMÍNIOS
O sistema de nomes de domínio é um grande livreo de endereços. É uma maneira de
converter um nome de dominío, como www.google.com, no tipo de endereço IP
numérico que os computadores precisam para endereçar os pacotes de informação
que enviam pela rede.

CRIE  UM SOCKETE PARA UM NOME DE DOMÍNIO
Geralmente, vai querer que seu código cliente use o sistema DNS (Sistema de
Nomes de Domínios) para criar sockets. Assim, seus usuários não precisarão
procurar os endereços IP. Para usar DNS, você precisa modelar seus sockets de
cliente de uma maneira ligeiramente diferente:

    #include <netdb.h>//vai precisar incluir este header para a função getaddrinfo()
    ...
    struct addrinfo *res;
    struct addrinfo hints;
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = PF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    getaddrinfo("www.oreilly.com", 80, &hints, &res);

A função getaddrinfo() constrói uma nova estrutura de dados no heap chamada
recurso de nomes. O recurso de nomes representa uma porta em um servidor de com
um nome de domínio específico. Escondido dentro do recurso de nomes está o
endereço IP que o computador vai precisar. Às vezes, domínios muito grande
podem ter vários endereços IP, mas o código aqui vai simplesmente escolher um
deles. você pode então usar o recurso de nomes para cruar um socket.

    int s = socket(res->ai_family, res->ai_socktype, res-ai_protocol);

Finalmente, você pode se conectar ao socket remoto. Com o recurso de nomes foi
criado no heap, você precisará organizá-lo com uma função chamada
freeaddrinfo().
    
    //res->ai_addr é o endereço da porta e domínio
    connect(s, res->ai_addr, res->ai_addrlen);//res->ai_addrlen é o tamanho de endereço na memória.//Isso vai se conectar ao socket remoto
    freeaddrinfo(res);//quando tiver conectado, você pode excluir os dados de endereço com freeaddrinfo()

Quando tiver conectado um socket a uma porta remota, pode ler e escrever para
ele usando as mesma funções revc() e send() que usou para o servidor. Isso
significa que agora já deve ter informação suficiente para escrever um cliente
web...

