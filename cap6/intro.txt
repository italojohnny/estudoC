VOCÊ PRECISA DE ARMAZENAMENTO FLEXÍVEL?

Você viu diferentes tipos de dados que podem ser armazenados em C e também viu
como armazenar múltiplos dados em uma array. Mas, às vezes, você precisa ser um
pouco mais flexível.

Imagine que é o diretor de uma agência de turismo que organiza passeios
turísticos de avião pelas ilha. Cada passeio contém uma sequência de voos
curtos de uma ilha para a outra. Para cada uma das ilhas, você vai precidar
registrar algumas informações, como o nome dela e o horário de funcionamento do
seu aeroporto. Então, como poderia registrar esses dados?

Você poderia criar uma struct para representar uma ilha:

typedef struct {
    const char *name;
    const char *opens;
    const char *closes;
    struct island *next;
} island;

Agora, como o passeio passa por uma sequênciade ilhas, você vai precisar
registrar uma lista delas utilizando uma array de islands:

island tour[4];

Mas temos um problema. Array têm um tamanho fixo, ou seja, não são muito
flexívis. Você pode usar uma array se souber exatamente quantas ilhas serão
visitadas no passeio. Mas, e se precisar alterar o passeio? E se quiser
acrescentar um destino a mais no meio do camilho?

Para armazenar uma quantidade flexível de dados, você precisa de algo mais
extensível que uma array. Você precis de uma lista encadeada.

LISTAS ENCADEADAS SÃO COMO CORRENTES DE DADOS

Uma lista encadeada é um exemplo de uma estrutura de dados abstrata, porque uma
lista encadeada é geral: pode ser usada para armazenar muitos tipos diferentes
de dados.
Para entender como uma lista encadeada funciona, pense na nossa agência de
turismo. Uma lista encadeada armazena um dado, em um elo para um outro dado.

LISTAS ENCADEADAS PERMITEM INSERÇÕES

Como apenas poucas modificações, você pôde acrescentar uma nova etapa ao
passeio. Essa é uma vantagem que as listas encadeadas têm sobre arrays: a
inserção de dados é muito rápida. Se quisesse inserir um valor no meio de uma
array, teria de deslocar todos os dados seguintes um por um.
Então listas encadeadas possibilitam o armazenamento de quantidades variáveis
de dados e facilitam a inserção de dados adicionais.
Mas como se cria uma lista encadeada em C?

CRIE UMA ESTRUTURA RECURSIVA
Cada um dos structs na lista precisará se conectar ao struct seguinte. Uma
struct que contém um elo para outro struct do mesmo tipo se chama uma
estrutura recursiva.
Estruturas recursivas contêm ponteiros para outras estruturas do mesmo tipo.
Então, se tiver um horário de voos para a lista de ilhas que vai visitar, você
pode usar uma estrutura recursiva para cada ilha. Vamos ver como isso funciona
em maiores detalhes.
Como você armazena um elo de struct para o outro? Com um ponteiro. Assim os
dados d island irão conter o endereço da próxima ilha a ser visitada. Então,
quando nosso código estiver em umm island, sempre poderá pular para o island
seguinte.
Vamos escrever códido para começar a passear pelas ilhas.

ESTRUTURAS RECURSIVAS PRECISAM DE NOMES?
Se usar o comando typedef, você normalmente pode pular a parte de dar um nome
próprio ao struct. Mas, em uma estrutura recursiva, você precisa incluir um
ponteiro para o mesmo tipo. A sintaxe de C não permite a utilização do
pseudônimo typedef, então você precisa dar ao struct um nome próprio. Por isso
o struct aqui se chama struct island.

CRIE ILHAS EM C:
island amity = {"Amity", "09:00", "17:00", NULL};
island craggy = {"Craggy", "09:00", "17:00", NULL};

...e ligue-as para formar UM PASSEIO:
amity.next = &craggy;
craggy.next = &isla_nublar;

você precisa ter cuidado pata atribuiro endereço da próxima ilha ao atributo
next de cada struct island. Você vai usar variáveis struct para cada uma das
ilhas.
então agora você criou um passeio completo pelas ilhas em C. Mas e se quiser
inseriruma visita a skull island entre Isla Nubla e Shuller Island?

INSERINDO VALORES NA LISTA
Você pode inserir island, como fez antes, mudando o valos dos ponteiros entre
ilhas:

island skull = {"Skull", "09:00", "17:00", NULL};
isla_nublar.next = &skull;
skull.next = &shutter;


"Hmmm... Até agora usamos uma variável separada para cada item na lista. Mas,
se não soubermos o tamanho do arquivo, como vamos saber quantas variáveis são
necessárias? Será que existe uma maneira de gerar novo espaço de armazenamento
à medida que houver  necessidade?"

SIM, VOCÊ PRECISA, DE ALGUMA MANEIRA, CRIAR ARMAZENAMENTO DINÂMICO.
Todos os programas que você criou até agora usaram armazenamento estático. Cada
vez que precisou armazenar algo, adicionou uma variável ao código. Aquelas
variáveis geralmente têm sido armazenadas no stack. Lembre-se: o stack é o
espaço na memória reservado para o armazenamento de variáveis locais.
Quando você criou as primeiras ilhas, você fez isso:

island amity = {"Amity", "09:00", "17:00", NULL};
island craggy = {"Craggy", "09:00", "17:00", NULL};

Cada struct island precisou de uma variável própria. Esse trecho de código
sempre vai criar exatamente duas islands, você precisaria de outra variável
local. Isso é ótimo, se você souber quantos dados, precisa armazenar ao
desenvolvero programa, mas muitas vezes os programas não sabem quanto será
necessário armazenar até o tempo de execução. Se estiver criando um navegador
web, por exemplo, você não vai saber quantos dados vai precisar para armazenar
uma página web até carregá-la. Então, programas em C precisam de alguma maneira
de dizer ao sistema operacional que eles precisam de mais espaço de
armazenamento à medida que houver necessidade.
Programas precisam de armazenamento dinâmico.

USE O HEAP PARA ARMAZENAMENTO DINÂMICO.
Em geral, a seção de memória que você tem usado até agora é o stack. O stack é
a seção da memória utilizada para variáveis locais. Cada dado é armazenado em
uma variável, e cada variável desaparece assim que você sair da função.
O problema é que é difícil conseguir mais espaço de armazenamento no stack
durante o tempo de execução, e é aí que o heap entra em jogo. O heap é a seção
da memória onde o programa armazena os dados que devem estar disponíveis por um
tempo maior. Não vai se esvaziar automaticamente, então é o lugar perfeito
para armazenar estruturas de dados como nossa lista encadeada. Você pode
comparar o armazenamento no heapa a um armário reservado no vestiário.

PRIMEIRO, PEGUE SUA MEMÓRIA COM MALLOC()
Imagine que seu programa de repente precise armazenar grandes quantidades de
dados em tempo de execução. Isso é semelhante a reservar um grande armário para
armazenar os dados, e, em C, você faz isso com uma função chamada malloc().
Você diz para a função malloc() exatamente de quanta memória você precisa, e
ela pede ao sistema operacional para reservar aquela quantidade de memória no
heap. Depois disso a função malloc() retornar um ponteiro para o novo espaço no
vestiário. Isso te deixa acessar a memória e também pode ser usado para manter
o controle do armário de armazenamento que foi alocado.

DEVOLVA A MEMÓRIA QUANDO TERMINAR
A vantagem de memória heap é que você pode ficar com ela por bastante tempo. A
desvantagem é que... você pode ficar com ela por bastante tempo.
Quando você apenas estava usando o stack, não precisava se preocupar sobre
devolver a memória; tudo acontecia automaticamente. Cada vez que sair de uma
função, o armazenamento local é liberado no stack.
O heap é diferente. Após reservar espaço no heap, tal espaço nunca estará
disponível, a não ser que você avise para a Biblioteca Padrão C que você terminou
de usá-lo. A memória heap disponível é limitada. Então, se o seu código
continuar pedindo mais espaço no heap, seu programa vai começar a ter vazamento
de memória.
Um vazamento de memória ocorre quando um programa pede mais e mais memória sem
liberar aquela que não está mais usando. Vazamentos de memória são um dos bugs
mais comuns em programas em C e podem ser muito difíceis de detectar.

LIBERE A MEMÓRIA USANDO A FUNÇÃO FREE()
A função malloc() aloca espaço e retorna um ponteiro para o espaço reservado.
Você vai precisar deste ponteiro para acessar os dados e, depois de terminado
de usá-los, precisa liberar a memória usando a função free(). É semelhante a
devolver sua chave do guarda-volumes para seu armário poder ser reutilizado.
Cada vez que alguma parte do seu código pedir armazenamento no heap com função
malloc(), deve haver uma parte do código que devolve o espaço de armazenamento
com a função free(). Quando seu programa terminar de ser executado, todo o
armazenamento no heap será liberado automaticamente, mas é uma boa pratica
chamar explicitamente a função free() para cada espaço de memória dinâmica que
criar.
Vamos ver como malloc() e free() funcionam.

PEÇA MEMÓRIA COM MALLOC()...
A função que pede memória se chama malloc(), abreviação de memory allocation
(alocação de memória). malloc() recebe um único parâmetro: o número de bytes
que você precisa. A maioria das vezes você não sabe exatamente quanta memória
você precisa em byte, então malloc() quase sempre é usado com um operador
chamado sizeof, assim:

#include <stdlib.h>
malloc(sizeof(island));

sizeof retorna a quantidade de byte que um tipo de dado ocupa no seu sistema.
Pode ser um struct ou tipo básico de dados, como int ou double.
A função malloc separa um pedaço da memória para você, depois retorna um
ponteiro contendo o endereço do início. Mas que tipo de ponteiro vai ser?
malloc na verdade retorna um ponteiro para uso geral, com tipo void*.

island *p = malloc(sizeof(island));

...E LIBERE A MEMÓRIA COM FREE()
Após criar a memória no heap, você pode usá-la o quanto quiser. Mas, quando
tiver terminado, você precisa liberar a memória usando a função free().
free() precisa do endereço de memória que a função malloc() criou. Contanto que
a biblioteca saiba onde o pedaço de memória começa, será possível verificar os
registros para ver quanta memória deve ser liberada. Então, se quisesse liberar
a memória alocada acima, poderia fazer assim:

free(p);

Ok, agora que sabemos mais sobre memória dinâmica, podemos começar a escrever
código.
