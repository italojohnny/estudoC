COMUNICAÇÃO EMTRE PROCESSOS

REDIRECIONANDO A ENTREDA E A SAÍDA
Quando você executa programas na linha de comando, pode redirecionar a saída
padrão usando o operado >:

    python ./rssgossip.py Snooki > stories.txt

A Saída Padrão é um dos três fluxos de dados padrão. Um fluxo de dados é
exatamente o que o nome indica: um fluxo de dados que entra ou sai de um
processo. Há fluxos de dados para a Entrada, a Saída e o Erro Padrão; e também
há fluxos dados para outros coisas, como arquivos e conexões de redes. Quando
você redireciona a saída de um processo, você altera o destino dos dados.
Então, ao invés de enviar os dados para a tela, você pode fazer com que a Saída
Padrão envie os dados para um arquivo.
Redirecionamento é muito útil na linha de comando, mas será que existe alguma
maneira de fazer com que o processo se redirecione?

OLHANDO POR DENTRO DE UM PROCESSO TÍPICO
Cada processo contém o programa que ele está executando, além do espaço para
dados do stack e heap. Mas o processo também precisa de algum lugar para
registrar onde os fluxo de dados é representado por um descritor de arquivo,
que na realidade é apenas um número. O processo mantém o controle de tudo,
armazenando os descritores de arquivo e seus fluxos de dados em um tabela de
descritores.
A tabela de descritores tem uma coluna onde se registra cada número dos
descritores de arquivo. Apesar de estes serem chamados de descritores de
arquicos, é possível que não estejam conectados a um arquivo real no disco
rígido. Ao lado d cada descritor de arquivo a tabela registra o fluxo de dados
a ele associado. O fluxo de dados pode ser um conexão ao teclado ou à tela, um
ponteiro para um arquivo, ou uma conexão de rede.
Os três primeiros lugares na tabela são sempre os mesmo. A posição 0 é para a
entrada padrão, a posição 1 é para a saída padrão, e a posição 2 é para o erro
padrão. As outras na tabela ou ficam vazias ou registram conexões a fluxos de
dados que foram criadas pelo processo. Por exemplo, cada vez que o código abre
um arquivo para leitura ou escrita, outra posição é preenchida na tabela de
descritores.
Quando o processo é criado, a entrada padrão está conectada ao teclado, e a
saida e o erro padrao estao conectados a tela. Tudo permanecerá assim até
alguém faça um redirecionamento.
-----------------------------
|#|Fluxo de dados           |
-----------------------------
|0|O teclado                |
|1|A tela                   |
|2|A tela                   |
|3|Conexão do banco de dados|
-----------------------------

REDIRECIOMENTO SIMPLEMENTE SUBSTITUI O FLUXO DE DADOS
A entrada, a saída e o erro padrão têm posições fixas na tabela de descritores.
Mas os fluxos de dados para qual eles apontam podem ser modificados.
Isso significa que, se você quiser redirecionar a saída padrão, você precisa
apenas trocar o fluxo de dados associado ao descritor 1 na tabela.
Todas as funções, como printf(), que enviam dados para a saída padrão,
primeiramente, olham a tabela de descritores para saber para onde o descritor 1
aponta. Depois elas escrevem os dados no fluxo de dados correto.

PROCESSOS PODEM SE REDIRECIONAR
Até agora, cada vez que usou redirecionamento, você o fez a partir da linha de
comando usando os operadores > e <. Mas processo podem fazer seus próprios
redirecionamentos reconfigurando a tabela de descritores.

FILENO() TE DIZ QUAL É O DESCRITOR
Cada vez que você abre um arquivo, o sistema operacional registra um novo item
na tacela de descritores. Digamos que você abra um arquivo com algo assim:

    FILE *my_file = fopen("guitar.mp3", "r");

O sistema operacional vai abrir o arquivo guitar.mp3 e retornar um ponteiro
para ele, mas também vai percorrer a tabela de descritores até encontrar um
espaço vazio para registrar o novo arquivo.
Mas, uma vez que tiver um ponteiro para o arquivo, como você o encontra na
tabela de descritores? A resposta é chamando a função fileno().

    int descriptor = fileno(my_file);//isso vai retornar o valor 4

fileno() é uma das poucas funções de sistema que não retorna -1, caso ocorra
uma falha. Se você passar um ponteiro que aponta um arquivo aberto para
fileno(), ele sempre deve retornar o número do descritor.

//o que acontece se eu passar NULL para fileno()?

DUP2() CRIA UMA DUPLICATA DOS FLUXOS DE DADOS
Abrir um arquivo vai preencher uma posição na tabela de descritores, mas e se
você quiser modificar o fluxo de dados que já está registrado e associado a um
descritor? E se você quiser mudar o descritor de arquivo 3 para que ele aponte
para um fluxo de dados diferente? Você pode fazer isso com a função dup2().
dup2() cria uma duplicata de fluxo de dados, copiando o conteúdo de uma posição
na tabela para outra. Então, se você tiver um ponteiro de arquivo para
guitar3.mp3 associado ao descritor 4, o seguinte código vai conectá-lo ao
descritor de arquivo 3 também.

    dup2(4, 3);

-----------------------------
|#|Fluxo de dados           |
-----------------------------
|0|O teclado                |
|1|A tela                   |
|2|A tela                   |
| |Conexao de banco de dados|
|3|Arquivo guitar.mp3       |
|4|Arquivo guitar.mp3       |
-----------------------------

Ainda há apenas um arquivo guitar.mp3, e ainda há apenas um fluxo de dados
conectado a ele. Mas o fluxo de dados (o FILE*) agora está registrado xom os
descritores de arquivo 3 e 4;
Agora que você sabe como encontrar e modificar coisas na tabela de descritores,
você deveria ser capaz de redirecionar a saída padrão de um processo para
apontar para um arquivo.

ÀS VEZES, VOCÊ PRECISA ESPERAR...
O programa newshound2 inicializa processos separados para executar o script
rssgossip.py. Mas, quando aquele processo filho é criado, ele é independente do
seu pai. Você poderia executar o programa newshound2 e ainda ter um arquivo
stories.txt vazio, porque rssgossip.py ainda não terminou. Isso significa que o
sistema operacional precisa lhe dar uma maneira de esperar até o processo filho
ficar completo.

A FUNÇÃO WAITPID()
O programa newshound2 inicializa processos separados para executar o script
rssgossip.py. Mas, quando aquele processo filho é criado, ele é independente do
seu pai. Você poderia executar o programa newshound2 e ainda ter um arquivo
stories.txt vazio, porque rssgossip.py ainda não terminou. Isso significa que o
sistema operacional precisa lhe dar uma maneira de esperar até o processo filho
ficar completo.

A FUNÇÃO WAITPID()
A função waitpid() não vai retornar até o processo filho morrer(). Isso
significa que você pode acrescentar um pouco de código ao seu programa, para
ele não ser encerrado até o script rssgossip.py terminar de ser executado:

waitpid() aceita três parâmetros:
    waitpid(pid, &pid_status, option)

    (*) PID
        Esse é o ID do processo que foi dado pelo pai quando ele uso fork()
        para criar o filho.
    (*) PID_STATUS
        Isso vai armazenar informações de encerramento (exit) sobre o processo;
        waitpid() vai atualizá-lo, então isso precisa ser um  ponteiro.
    (*) OPTIONS
        Há diversas opções (options) que você pode passar para waitpid(), e
        digitar man waitpid vai exibir mais informações. Se você atribuir 0 ao
        campo options, a função espera até o processo terminar.

O QUE É STATUS?
Quando a função waitpid() termina de esperar, ela armazena um valor em
pid_status que indica a você como o processo foi. Para achar o status exit do
processo filho, você vai precisar passar o valor de pid_status a um macro
chamado WEXITSTATUS (pid_status):

    if (WEXITSTATUS(pid_status))
        puts("Error status non-zero");

Por que você precisa do macro? Porque o pid_status contém várias informações, e
apenas os primeiros 8 bits representam o status exit. O macro te diz qual é o
valor daqueles 8 bits.

FIQUE EM CONTATO COM SEU FILHO
Você viu como executar um processo separado, usando exec() e fork(), e você
sabe como redirecionar a saída de um processo filho para um arquivo. Mas, e se
você quiser observar um processo filho diretamente? Isso é possível? Ao invés
de esperar um processo filho enviar todos os dados a um arquivo e depois lê-lo,
existe alguma maneira de inicializar um processo e ler o dados gerados em tempo
real?

LENDO LINKS DE NOTÍCIAS DE RSSGOSSIP
Como exemplo, há uma opção no script rssgossip.py que permit a exibição de URLs
de qualquer notícia que ele encontrar.
Você poderia executar o script e salvar a saída em um arquivo, mas isso iria
demorar. Seria muito melhor se os processos pai e filho pudessem conversar uns
com os outros enquanto o processo filho estiver em execução.

    python rssgossip.py -u 'pajama death' | grep 'http'

CONECTE SEUS PROCESSO COM PIPE
Você já usou algo que faz conexão ao vivo entre processos: pipes.
Pipes são usados na linha de comando para conectar a saída de um processo à
entrada de outro processo. Neste exemplo, você está executando o script
rssgossip.py manualmente e, depois, processando sua saída por um comando
chamado grep. O comando grep encontra todas as linhas contendo http.

comandos usando pipe são pais e filhos
Quando você junta comandos com pipe na linha de comando, na realidade você está
conectando-os como processo pai e processo filho. Então, no exemplo acima, o
comando grep é o pai do rssgossip.py.
    (1) A linha de comando cria o processo pai
    (2) O processo pai usa fork e coloca o script rssgossip.py em um processo filho.
    (3) O pai conecta a saída do filho com a entrada do pai, usando um pipe.
    (4) O processo pai usa exec no comando grep.
Pipes são usandos na linha de comando para possibilitar a conexão entre
processos. Mas, e se você estiver apenas usando código em C? Como você liga um
pipe ao seu processo filho para ler a saída logo que for gerada?

ESTUDO DE CASO: ABRINDO HISTÓRIAS EM UM NAVEGADOR
Digamos que você queira executar o script rssgossip.py e, depois, abrir as
histórias que ele encontrar em um navegador web. Seu programa será executado no
processo pai e rssgossip.py será executado no filho. Você precisa criar um
pipe que conecta a saída de rssgossip.py à entrada do seu programa.
Mas como se cria um pipe?

PIPE() ABRE DOIS FLUXO DE DADOS
Como o filho vai enviar dados para o pai, você precisa de um pipe que esteja
ligado à Saída Padrão do filho e à Entrada Padrão do pai. Você vai criar o pipe
usando a função pipe(). Lembrra-se de que dissemos que cada vez que você abre
um fluxo de dados para algo como um arquivo, ele é acresentado à tabela de
descritores? Bem, é exatamente isso que a função pipe() faz: cria dois fluxos
de dados conectados e os acrescenta à tabela. O que for escrito em um fluxo de
dados poderá ser lido no outro.
Quando pipe() cria as duas linhas na tabela de descritores, também armazena os
descritores de arquivo em um array de dois elementos:
    
    int fd[2];//os descritores serão armazenados neste array;
    if (pipe(fd) == -1) {//você passa o nome do array à função pipe()
        error("Can't creat the pipe");
    }
O comando pipe() cria um pipe e dá dois descritores: fd[1] é o descritor que
escreve no pipe e fd[0] é o descritor que lê o que vem do pipe. Quando tiver os
descritores, você precisará usá-los nos processo pai e filho.

NO FILHO
No processo filho, você precisa fechar a ponta fd[0] do pipe e, depois, mudar a
Saída Padrão do processo filho para ela apontar para o mesmo fluxo de dados que
o descritor fd[1].

    //O filho não vai ler o que vier do pipe
    close(fd[0]);//isso vai fechar a ponta final do pipe;
    dup2(fd[1], 1);//depois o filho conecta a ponta de escrita à saída padrão

Isso significa que tudo que o filho enviar para a saída padrão será escrito no
pipe.

NO PAI
No processo pai, você precisa fechar a ponta fd[1] do pipe (porque não vai
escrever nele) e redirecionar a entrada padrão do processo pai para ler dados
vindos do mesmo lugar que o do descritor fd[0]:
    
    //O pai conecta a ponta final à saída padrão
    dup2(fd[0], 0);//fd[0] é a ponta final do pipe
    close(fd[1]);//isso vai fechar a ponta de escrita do pipe

Tudo que o filho for escrever no pipe será lido pela entrada padrão do processo
pai.

ABRINDO UMA PÁGINA WEB EM UM NAVEGADOR
Seu programa vai precisar abrir uma páfina web usando o navegador da máquina.
Isso é um pouco difícil, porque diferentes sistemas operacionaid têm jeitos
diferentes de conversar com programas como navegadores web.

