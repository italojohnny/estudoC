CHAMADAS AO SISTTEMA SÃO SUA CONEXÃO AO SO
Programas em C dependem do sistema operacional praticamente para tudo. Os
programas fazem chamadas de sistema se quiserem conversar com o hardware.
Chamadas de sistema são apenas funções que vivem dentro do kernel do sistema
operacional. A maior parte do código na Biblioteca Padrão de C depende deles.
Quando você chama printf() para exibir algo na linha de comando, em algum lugar
nos bastidores uma chamada ao sistema será feita para o sistema operacional
enviar a string de texto para a tela.
Vamos ver um exemplo de uma chamada ao sistema. Vamos começar com uma chamada
(adequadamente) system().
system() toma um parâmetro de string simples e executa como se você tivesse
digitado na linha de comando.:

    system("gedit");//isso vai inicializar um editor de texto

A função system() é uma maneira fácil de executar outros programas a partir do
seu código - especialmente se você está criando um protótipo e prefere usar
programas externos a escrever muito código em C:

AÍ ALGUÉM INVADIU O SISTEMA...
Há uma desvantagem em usar a função system(). É rápida e fácil de usar, mas
também é um pouco desorganizada. Antes de detalhar os problemas da função
system(), vamos ver o que é preciso para quebrar o programa.
O código funciona juntando uma string que contém um comando, assim:

    echo ' <comment>  <timestamp>  '>> reports.log

Mas e se alguém digitar um comentário como este?

    echo ' ' && ls && echo ' <timestamp> '>> reports.log

Ao injetar código da linha de comando no texto, você pode fazer com que o
programa execute o que você quiser:
Isso é um problema sério? Se um usuário puder executar guard_log, ele também
poderá executar algum outro programa. Mas e se seu código for chamado por um
servidor web? Ou se estiver processando dados de um arquivo?

SEGURANÇA NÃO É O ÚNICO PROBLEMA
Esse exemplo injeta um trecho de código que lista o conteúdo do diretório raiz,
mas ele poderia tter excluído arquivos ou instalando um vírus. Mas você não
deveria se preocupar apenas com a segurança.

    (*) E se os comentários tiverem apóstrofos?
    Isso pode quebrar a estrutura do mando.
    (*) E se a variável PATH fizer a função system() chamar o programa errado?
    (*) E se o programa que estamos chamando precisar de um conjunto de variáveis
    de ambiente específicas já configuradas?

A função system() é fácil de usar, mas, na maioria das vezes, você vai precisar
de algo mais estruturado - alguma maneira de chamar um programa específico, com
um conjunto de parâmetros da linha de comnado e, talvez, até algumas variáveis
de ambiente.
KERNEL É RESPONSAVEL POR TRÊS COISAS: PROCESSOS, MEMÓRIA E HARDWARE

AS FUNÇÕES EXEC() LHE DÃO MAIS CONTROLE
Quando você chama a função system(), o sistema operacional precisa interpretar
a string com o comando e decidir quais programas executar e como executá-los. E
é aí que surge o problema: o sistema operacional precisa interpretar a string,
e você já sabe que é muito fácil errar a interpretação. Então a solução é
remover a ambiguidade e dizer ao sistema operacional exatamente que programa
você quer executar. É para isso que as funções exec() server:

FUNÇÕES EXEC() SUBSTITUEM O PROCESSO ATUAL
Um processo é apenas um programa sendo executado na memória. Se digitar
taskemgr no Windows ou ps -ef na maioria das outras máquinas, você verá os
processos sendo executados no seu sistema. O sistema operacional mantém o
controle de cada processo com um número chamado identificador de processos
(PID).
As funções exec() substitum o processo atual executando algum outro programa.
Você pode dizer que parâmetros da linha de comando ou variáveis de ambiente
usar e, quando o novo programa iniciar, ele terá exatamente o mesmo PID que o
programa substituído. É como uma corrida de revezamento quando o seu programa
entrega o seu processo para o novo programa.

HÁ VÁRIAS FUNÇÕES EXEC()
Como o passar do tempo, programadores criaram diversas versões diferentes de
exec(). Cada versão tem um nome ligeramente diferente e seu próprio conjunto de
parâmetros. Mesmo havendo várias versões, na realidade existem apenas dois
grupos de funções exec(): as funções lista e as funções array.

AS FUNÇÕES LISTA: EXECL(), EXECLP(), EXECLE()
As funções lista aceitam parâmetros da linha de comando como uma lista de
parâmetros, assim:
(*) O PROGRAMA
    Isso pode ser o pathname completo do programa - execl()/execle() - ou
    apenas um nome de um comando para buscar - execlp() -, mas primeiro
    parâmetro diz à função exec() que programa ela vai executar.
(*) OS PARÂMETROS DA LINHA DE COMANDO.
    Você precisa listar cada parâmetro da linha de comando que deseja usar.
    Lembre-se: o primeiro parâmetro da linha de comando é sempre o nome do
    programa. Isso significa que os dois primeiro parâmetros passados a uma
    versão lista de exec() sempre deveriam ser iguais.
(*) NULL
    Isso mesmo. Depois do últio parâmetro da linha de comando, você precisa de
    um NULL. Isso diz para a função que não há mais parâmetros.
(*) VARIÁVEIS DE AMBIENTE (TALVEZ)
    Se você chamar uma função exec() cujo nome termina com... e(), você também
    pode passar um array de variáveis de ambiente. Isso é apenas um array de
    strings, como "POWER=4", "SPEED=17", "PORT=OPEN"...

    execl("/home/flynn/clu", "/home/flynn/clu", "paranoids", "contract", NULL)

    execlp("clu", "clu", "paranoids", "contract", NULL)

    execle("/home/flynn/clu", "/home/flynn/clu", "paranoids", "contract", NULL, env_vars)

AS FUNÇÕES ARRAY: EXECV(), EXECVP(), EXECVE()
Se você já tiver armazenado seus parâmetros da linha de comando em um array,
talvez essas duas versões sejam mais fáceis de usar:

    execv("/home/flynn/clu", my_args);
    execvp("clu", my_args);

A única diferença entre essas duas funções é que execvp irá procurar o programa
usando a variável PATH.

COMO LEMBRAR DAS FUNÇÕES EXEC()
Você pode descobrir que função exec() você precisa construindo o nome. Cada
função exec() pode ser seguida por um ou dois caracteres, que devem ser l, v, p,
ou e. Os caracteres mostram quais utilidades pertencem a cada versão. Então,
para a função execle():

execle = exec + l + e = lista de parâmetros + um ambiente (environment)

Os caracters l e v sempre vêm antes do p e e, e os caracteres p e e são
opcionais.
-------------------------------------
|         USO            | CARCTARE |
|-----------------------------------|
|Lista de parâmetros     |    l     |
|Array de parâmetros     |    v     |
|-----------------------------------|
|Buscar no path          |    p     |
|Variáveis de ambiente   |    e     |
-------------------------------------

PASSANDO VARIÁVEIS DE AMBIENTE
Cada processo tem um conjunto se variáveis de ambiente. Esses são os valores
que você vê quando digita set ou env na linha de comando, e eles geralmente dão
informações úteis ao processo, como a localização do diretório principal ou
onde encontrar os comandos. Programas em C podem ler variáveis d ambiente com a
chamada ao sistema getenv().
Se você quiser executar um programa, usando parâmetros da linha de comando e
variáveis de ambiente, você pode fazer assim>

    char *my_env[] = {"JUICE=peach and apple", NULL};
    execle("diner_info", "diner_info", "4", NULL, my_env);

A função execle() vai configurar os parâmetros na linha de comando e as
variáveis de ambiente e, depois, substituir o processo atual com diner_info.

MAS E SE HOUVER UM PROBLEMA?
Se tiver um problema ao chamar o programa, o processo atual continuará sendo
executado. Isso é útil, porque significa que, se você não conseguir iniciar
arquele segundo processo, você poderá se recuperar do erro e dar ao usuário
mais informações sobre o que deu errado. E, felizmente, a Biblioteca Padrão de
C oferece código built-in para te auxiliar.

A MAIORIA DAS CHAMADAS DE SISTEMA COMETE O MESMO ERRO
Como a maioria das chamadas de sistemas dependem de algo fora do seu programa,
as coisas podem dar errado de alguma forma além do seu controle.
Por exemplo, a chamada ao sistema execle(). É muito fácil perceber quando uma
chamada exec dá errado. Se uma chamada exec() for bem sucedida, o programa
atual para de ser executado. Então, se o programa executar qualquer coisa
depois daa chamada exec(), deve haver um problema:

    execle("diner_info", "diner_info", "4", NULL, my_env);
    puts("Dude - the diner_info code must be busted");

Mas determinar se uma chamada ao sistema funcionou não é o bastante. Você
geralmente quer saber por que uma chamada ao sistema falhou. Por isso, a
maioria das chamadas de sistema segue as heurísticas do fracasso.
A variável errno é uma variável global que é definida no arquivo errno.h, além
de vários valores de erro padrão, como:
    
    epern = 1       Operação não permitida
    enorent = 2     Não existe tal arquivo ou diretório
    esrch = 3       Não existe tal processo

Agora você poderia verificar o valor de errno e comparálo como essa linha, ou
vocÇe poderá procurar um trecho padrão de uma mensagem de erro usando uma
função
em string.h chamada strerror():
    
    puts(streeror(errno));

Então, se o sistema não puder encontrar o programa que você está executando e
atribuir enoent à variável errno, o código acima exibira esta mensagem:

    No such file or diretory

LEIA AS NOTÍCIAS COM RSS
Feeds RSS são muito comuns em sites que publicam suas histórias mais recentes.
Cada feed RSS é apenas um arquivo XML que contém um resumo das histórias e
links. Claro que é possível escrever um programa em C que vai ler os arquivos
RSS direto da web, mas isso envolve alguns conceitos de programação que você
ainda não viu. Mas isso não é um problema se você encontrar um outro programa
que pode lidar com  o processamento RSS.
RSS Gossip é um pequeno script em Python que faz buscas em feeds RSS,
procurando histórias contendo um certo texto. Para rodar o script, você precisa
ter Python instalado. Quando tiver python e rssgossip.py, você pode procurar
histórico assim:

export RSS_FEED=http://rss.cnn.com/rss/edition_world.rss
python rssgossip.py 'China'

EXEC() É O FIM DA LINHA PARA O SEU PROGRAMA
As funções exec() substituem a função atual, executando um novo programa. Mas o
que acontece com o programa original? Ele é encerrado, e é encerrado
imediatamente. Por isso que o programa só rodou o script rssgossip.py para o
primeiro feed de notícias. Depois que chamou execle() na primeira vez, o
programa newshound foi encerrado.
Mas o que fazer se você quiser começar um outro processo e manter seu processo
original em execução?

FORK() VAI CLONAR SEU PROCESSO
Você vai evitar esse problema usando uma chamada ao sistema que se chama
fork().
fork() cria uma cópia completa do processo atual. A nova cópia estará
executando o mesmo programa, com os mesmos detalhes. Ela terá exatamenteas
mesmas variáveis que irão  conter exatamente os mesmos valores. A única
diferença é que o processo cópia terá um identificador de processo diferente do
original.
O processo original se chama processo pai, e a cópia recém-criada se chama
processo filho.
Mas clonar o processo atual resolve os problemas com exec()? Vejamos.

Executando um processo filho com fork() + exec()
O macete é apenas chamar uma função exec() em um processo filho. Assim, seu
processo pai original poderá continuar sendo executado. Vamos ver o processo
passo a passo.

1. FAÇA UMA CÓPIA
    Comece fazendo uma cópia do seu processo atual usando a chamada ao sistem
    fork().
    Os processos precisam saber qual deles é o processo pai e qual é o filho,
    então a função fork() retorna 0 para o processo filho e um valor diferente
    de zero para o processo pai.

2. SE VOCÊ FOR O PROCESSO FILHO, CHAME EXEC()
    Nesse ponto, você tem dois processos idênticos sendo executados, ambos
    usando código idêntico. Mas agora o processo filho (aquele que recebeu 0 da
    chamada fork()) precisa se substituir, chamando exec().:

Agora você tem dois processos separados: o processo filho está executando o
script rssgossip.py, e o processo pai original está livre para fazer outra
coisa.
