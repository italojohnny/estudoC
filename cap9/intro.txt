CHAMADAS AO SISTTEMA SÃO SUA CONEXÃO AO SO
Programas em C dependem do sistema operacional praticamente para tudo. Os
programas fazem chamadas de sistema se quiserem conversar com o hardware.
Chamadas de sistema são apenas funções que vivem dentro do kernel do sistema
operacional. A maior parte do código na Biblioteca Padrão de C depende deles.
Quando você chama printf() para exibir algo na linha de comando, em algum lugar
nos bastidores uma chamada ao sistema será feita para o sistema operacional
enviar a string de texto para a tela.
Vamos ver um exemplo de uma chamada ao sistema. Vamos começar com uma chamada
(adequadamente) system().
system() toma um parâmetro de string simples e executa como se você tivesse
digitado na linha de comando.:

    system("gedit");//isso vai inicializar um editor de texto

A função system() é uma maneira fácil de executar outros programas a partir do
seu código - especialmente se você está criando um protótipo e prefere usar
programas externos a escrever muito código em C:

AÍ ALGUÉM INVADIU O SISTEMA...
Há uma desvantagem em usar a função system(). É rápida e fácil de usar, mas
também é um pouco desorganizada. Antes de detalhar os problemas da função
system(), vamos ver o que é preciso para quebrar o programa.
O código funciona juntando uma string que contém um comando, assim:

    echo ' <comment>  <timestamp>  '>> reports.log

Mas e se alguém digitar um comentário como este?

    echo ' ' && ls && echo ' <timestamp> '>> reports.log

Ao injetar código da linha de comando no texto, você pode fazer com que o
programa execute o que você quiser:
Isso é um problema sério? Se um usuário puder executar guard_log, ele também
poderá executar algum outro programa. Mas e se seu código for chamado por um
servidor web? Ou se estiver processando dados de um arquivo?

SEGURANÇA NÃO É O ÚNICO PROBLEMA
Esse exemplo injeta um trecho de código que lista o conteúdo do diretório raiz,
mas ele poderia tter excluído arquivos ou instalando um vírus. Mas você não
deveria se preocupar apenas com a segurança.

    (*) E se os comentários tiverem apóstrofos?
    Isso pode quebrar a estrutura do mando.
    (*) E se a variável PATH fizer a função system() chamar o programa errado?
    (*) E se o programa que estamos chamando precisar de um conjunto de variáveis
    de ambiente específicas já configuradas?

A função system() é fácil de usar, mas, na maioria das vezes, você vai precisar
de algo mais estruturado - alguma maneira de chamar um programa específico, com
um conjunto de parâmetros da linha de comnado e, talvez, até algumas variáveis
de ambiente.
KERNEL É RESPONSAVEL POR TRÊS COISAS: PROCESSOS, MEMÓRIA E HARDWARE

AS FUNÇÕES EXEC() LHE DÃO MAIS CONTROLE
Quando você chama a função system(), o sistema operacional precisa interpretar
a string com o comando e decidir quais programas executar e como executá-los. E
é aí que surge o problema: o sistema operacional precisa interpretar a string,
e você já sabe que é muito fácil errar a interpretação. Então a solução é
remover a ambiguidade e dizer ao sistema operacional exatamente que programa
você quer executar. É para isso que as funções exec() server:

FUNÇÕES EXEC() SUBSTITUEM O PROCESSO ATUAL
Um processo é apenas um programa sendo executado na memória. Se digitar
taskemgr no Windows ou ps -ef na maioria das outras máquinas, você verá os
processos sendo executados no seu sistema. O sistema operacional mantém o
controle de cada processo com um número chamado identificador de processos
(PID).
As funções exec() substitum o processo atual executando algum outro programa.
Você pode dizer que parâmetros da linha de comando ou variáveis de ambiente
usar e, quando o novo programa iniciar, ele terá exatamente o mesmo PID que o
programa substituído. É como uma corrida de revezamento quando o seu programa
entrega o seu processo para o novo programa.

HÁ VÁRIAS FUNÇÕES EXEC()
Como o passar do tempo, programadores criaram diversas versões diferentes de
exec(). Cada versão tem um nome ligeramente diferente e seu próprio conjunto de
parâmetros. Mesmo havendo várias versões, na realidade existem apenas dois
grupos de funções exec(): as funções lista e as funções array.

AS FUNÇÕES LISTA: EXECL(), EXECLP(), EXECLE()
As funções lista aceitam parâmetros da linha de comando como uma lista de
parâmetros, assim:
(*) O PROGRAMA
    Isso pode ser o pathname completo do programa - execl()/execle() - ou
    apenas um nome de um comando para buscar - execlp() -, mas primeiro
    parâmetro diz à função exec() que programa ela vai executar.
(*) OS PARÂMETROS DA LINHA DE COMANDO.
    Você precisa listar cada parâmetro da linha de comando que deseja usar.
    Lembre-se: o primeiro parâmetro da linha de comando é sempre o nome do
    programa. Isso significa que os dois primeiro parâmetros passados a uma
    versão lista de exec() sempre deveriam ser iguais.
(*) NULL
    Isso mesmo. Depois do últio parâmetro da linha de comando, você precisa de
    um NULL. Isso diz para a função que não há mais parâmetros.
(*) VARIÁVEIS DE AMBIENTE (TALVEZ)
    Se você chamar uma função exec() cujo nome termina com... e(), você também
    pode passar um array de variáveis de ambiente. Isso é apenas um array de
    strings, como "POWER=4", "SPEED=17", "PORT=OPEN"...

    execl("/home/flynn/clu", "/home/flynn/clu", "paranoids", "contract", NULL)

    execlp("clu", "clu", "paranoids", "contract", NULL)

    execle("/home/flynn/clu", "/home/flynn/clu", "paranoids", "contract", NULL, env_vars)

AS FUNÇÕES ARRAY: EXECV(), EXECVP(), EXECVE()
Se você já tiver armazenado seus parâmetros da linha de comando em um array,
talvez essas duas versões sejam mais fáceis de usar:

    execv("/home/flynn/clu", my_args);
    execvp("clu", my_args);

A única diferença entre essas duas funções é que execvp irá procurar o programa
usando a variável PATH.

COMO LEMBRAR DAS FUNÇÕES EXEC()
Você pode descobrir que função exec() você precisa construindo o nome. Cada
função exec() pode ser seguida por um ou dois caracteres, que devem ser l, v, p,
ou e. Os caracteres mostram quais utilidades pertencem a cada versão. Então,
para a função execle():

execle = exec + l + e = lista de parâmetros + um ambiente (environment)

Os caracters l e v sempre vêm antes do p e e, e os caracteres p e e são
opcionais.
-------------------------------------
|         USO            | CARCTARE |
|-----------------------------------|
|Lista de parâmetros     |    l     |
|Array de parâmetros     |    v     |
|-----------------------------------|
|Buscar no path          |    p     |
|Variáveis de ambiente   |    e     |
-------------------------------------

PASSANDO VARIÁVEIS DE AMBIENTE
Cada processo tem um conjunto se variáveis de ambiente. Esses são os valores
que você vê quando digita set ou env na linha de comando, e eles geralmente dão
informações úteis ao processo, como a localização do diretório principal ou
onde encontrar os comandos. Programas em C podem ler variáveis d ambiente com a
chamada ao sistema getenv().
Se você quiser executar um programa, usando parâmetros da linha de comando e
variáveis de ambiente, você pode fazer assim>

    char *my_env[] = {"JUICE=peach and apple", NULL};
    execle("diner_info", "diner_info", "4", NULL, my_env);

A função execle() vai configurar os parâmetros na linha de comando e as
variáveis de ambiente e, depois, substituir o processo atual com diner_info.

MAS E SE HOUVER UM PROBLEMA?
Se tiver um problema ao chamar o programa, o processo atual continuará sendo
executado. Isso é útil, porque significa que, se você não conseguir iniciar
arquele segundo processo, você poderá se recuperar do erro e dar ao usuário
mais informações sobre o que deu errado. E, felizmente, a Biblioteca Padrão de
C oferece código built-in para te auxiliar.

A MAIORIA DAS CHAMADAS DE SISTEMA COMETE O MESMO ERRO
Como a maioria das chamadas de sistemas dependem de algo fora do seu programa,
as coisas podem dar errado de alguma forma além do seu controle.
Por exemplo, a chamada ao sistema execle(). É muito fácil perceber quando uma
chamada exec dá errado. Se uma chamada exec() for bem sucedida, o programa
atual para de ser executado. Então, se o programa executar qualquer coisa
depois daa chamada exec(), deve haver um problema:

    execle("diner_info", "diner_info", "4", NULL, my_env);
    puts("Dude - the diner_info code must be busted");

Mas determinar se uma chamada ao sistema funcionou não é o bastante. Você
geralmente quer saber por que uma chamada ao sistema falhou. Por isso, a
maioria das chamadas de sistema segue as heurísticas do fracasso.
A variável errno é uma variável global que é definida no arquivo errno.h, além
de vários valores de erro padrão, como:
    
    epern = 1       Operação não permitida
    enorent = 2     Não existe tal arquivo ou diretório
    esrch = 3       Não existe tal processo

Agora você poderia verificar o valor de errno e comparálo como essa linha, ou
vocÇe poderá procurar um trecho padrão de uma mensagem de erro usando uma
função
em string.h chamada strerror():
    
    puts(streeror(errno));

Então, se o sistema não puder encontrar o programa que você está executando e
atribuir enoent à variável errno, o código acima exibira esta mensagem:

    No such file or diretory

